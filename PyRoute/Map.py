'''
Created on May 14, 2016

@author: tjoneslo
'''
import os
import logging
from pypdflite import PDFLite,PDFCursor
from pypdflite.pdfobjects.pdfline import PDFLine
from PIL import Image, ImageDraw, ImageColor
from StatCalculation import StatCalculation
from Galaxy import Sector
from Galaxy import Galaxy
from Star import Star

class Cursor (object):
    
    def __init__ (self, x, y):
        self.x = x
        self.y = y
        self.dx = 0
        self.dy = 0

    def set_deltas(self, dx=2, dy=2):
        self.dx = dx
        self.dy = dy

    @property
    def x(self):
        return self._x

    @x.setter
    def x(self, value=0):
        # If in left margin, sets to minimum value.
        self._x = value

    @property
    def y(self):
        return self._y

    @y.setter
    def y(self, value=0):
        self._y = value

    # Changes this cursor
    def x_plus(self, dx=None):
        """ Mutable x addition. Defaults to set delta value. """
        if dx is None:
            self.x += self.dx
        else:
            self.x = self.x + dx

    def y_plus(self, dy=None):
        """ Mutable y addition. Defaults to set delta value. """
        if dy is None:
            self.y += self.dy
        else:
            self.y = self.y + dy

class Map(object):

    def __init__(self, galaxy, routes):
        self.galaxy = galaxy
        self.routes = routes
        self.ym = 9     # half a hex height
        self.xm = 6     # half the length of one side
        self.colorStart = 0
        self.y_start = 43
        self.x_start = 15
        
    def document(self, sector):
        ''' Generated by the type of document'''
        raise NotImplementedError ("Base Class")
    
    def close(self):
        raise NotImplementedError ("Base Class")
        
    def cursor(self,x,y):
        ''' create a cursor (position) element'''
        raise NotImplementedError ("Base Class")
    
    def sector_name(self,doc,name):
        '''Write name at the top of the document'''
        raise NotImplementedError ("Base Class")
        
    def add_line(self, doc, start, end, color):
        ''' Add a line to the document, from start to end, in color'''
        raise NotImplementedError ("Base Class")
    
    def get_line(self, doc, start, end, colorname, width):
        ''' get a line draw method processor'''
        raise NotImplementedError ("Base Class")
        #color = pdf.get_color()
        #color.set_color_by_name(colorname)
        # hline = PDFLine(pdf.session, pdf.page, hlineStart, hlineEnd, stroke='solid', color=color, size=width)
    
    def write_maps(self):
        '''
        Starting point for writing PDF files. 
        Call this to output the trade maps
        '''
        logging.getLogger("PyRoute.Map").info("writing {:d} sector maps...".format(len(self.galaxy.sectors)))
        for sector in self.galaxy.sectors.itervalues():
            doc = self.document(sector)
            self.write_base_map(doc, sector)
            
            self.draw_borders(doc, sector)
            
            sector_trade = [star for star in self.galaxy.stars.edges_iter(sector.worlds, True) \
              if star[2]['trade'] > 0 and StatCalculation.trade_to_btn(star[2]['trade']) >= self.min_btn ]

            logging.getLogger('PyRoute.Map').debug("Worlds with trade: {}".format(len(sector_trade)))                

            sector_trade.sort(key=lambda line : line[2]['trade'])
            
            for (star,neighbor,data) in sector_trade:
                self.galaxy.stars[star][neighbor]['trade btn'] = StatCalculation.trade_to_btn(data['trade'])
                self.trade_line(doc, [star, neighbor], data)

            # Get all the worlds in this sector
            #for (star, neighbor, data) in self.galaxy.stars.edges_iter(sector.worlds, True):
            #    if star.sector != sector:
            #        continue#
            #    if data['trade'] > 0 and self.trade_to_btn(data['trade']) >= self.min_btn:
            #        self.galaxy.stars[star][neighbor]['trade btn'] = self.trade_to_btn(data['trade'])
            #        self.trade_line(doc, [star, neighbor], data)
            #    elif star.sector != neighbor.sector:
            #        data = self.galaxy.stars.get_edge_data(neighbor, star)
            #        if data is not None and \
            #            data['trade'] > 0 and \
            #            self.trade_to_btn(data['trade']) >= self.min_btn:
            #            self.trade_line(doc, [star, neighbor], data)

            for star in sector.worlds:
                self.system(doc, star)
            if sector.coreward:
                self.coreward_sector(doc, sector.coreward.name)
            if sector.rimward:
                self.rimward_sector(doc, sector.rimward.name)
            if sector.spinward:
                self.spinward_sector(doc, sector.spinward.name)
            if sector.trailing:
                self.trailing_sector(doc, sector.trailing.name)
            
            self.close()

    def write_base_map(self, doc, sector):
        # self.sector_name(doc, sector.name)
        self.subsector_grid(doc)
        self.hex_grid(doc, self._draw_all, 0.5)

    def subsector_grid(self, doc):
        vlineStart = self.cursor(0, self.y_start + self.xm)
        vlineEnd  = self.cursor(0, self.y_start + self.xm + (180 * 4))
        for x in xrange (self.x_start, 595, 144):
            vlineStart.x = x
            vlineEnd.x =  x
            self.add_line(doc, vlineStart, vlineEnd, 'lightgray')
        hlineStart = self.cursor(self.x_start, 0)
        hlineEnd   = self.cursor(591, 0)
        for y in xrange(self.y_start + self.xm, 780, 180):
            hlineStart.y=y
            hlineEnd.y = y
            self.add_line(doc, hlineStart, hlineEnd, 'lightgray')

    def hex_grid(self, doc, draw, width, colorname = 'gray'):
        
        hlineStart, hlineEnd, hline = self._hline(doc, width, colorname)
        llineStart, llineEnd, lline = self._lline(doc, width, colorname)
        rlineStart, rlineEnd, rline = self._rline(doc, width, colorname)
        
        for x in xrange (33):
            hlineStart.x_plus()
            hlineEnd.x_plus()
            self._hline_restart_y(x, hlineStart, hlineEnd)
            self._lline_restart_y(x, llineStart, llineEnd)
            self._rline_restart_y(x, rlineStart, rlineEnd)
            
            for y in xrange(41):
                hlineStart.y_plus()
                hlineEnd.y_plus()
                llineStart.y_plus()
                llineEnd.y_plus()
                rlineStart.y_plus()
                rlineEnd.y_plus()
                
                draw(x, y, hline, lline, rline)
                
            llineStart.x_plus()
            llineEnd.x_plus ()
            rlineStart.x_plus()
            rlineEnd.x_plus()

    def _draw_all(self, x, y, hline, lline, rline):
        if (x < 32):
            hline._draw()
        lline._draw()
        if (y > 0):
            rline._draw()

    def _hline(self, doc, width, colorname):
        hlineStart = self.cursor(0,0)
        hlineStart.x = 3
        hlineStart.y = self.y_start - self.ym
        hlineStart.dx = self.xm * 3
        hlineStart.dy = self.ym * 2

        hlineEnd   = self.cursor(0,0)
        hlineEnd.x = self.xm * 2.5
        hlineEnd.y = self.y_start - self.ym
        hlineEnd.dx = self.xm * 3
        hlineEnd.dy = self.ym * 2
        
        hline = self.get_line(doc, hlineStart, hlineEnd, colorname, width)
        return (hlineStart, hlineEnd, hline)

    def _lline(self, doc, width, colorname):
        llineStart = self.cursor(-10,0)
        llineStart.x = self.x_start
        llineStart.dx = self.xm * 3
        llineStart.dy = self.ym * 2

        llineEnd   = self.cursor(-10,0)
        llineEnd.x  = self.x_start + self.xm
        llineEnd.dx = self.xm * 3
        llineEnd.dy = self.ym * 2

        lline = self.get_line(doc, llineStart, llineEnd, colorname, width)
       
        return (llineStart, llineEnd, lline)

    def _rline(self, doc, width, colorname):
        rlineStart  = self.cursor(0,0)
        rlineStart.x = self.x_start + self.xm
        rlineStart.dx = self.xm * 3
        rlineStart.dy = self.ym * 2
        
        rlineEnd    = self.cursor(0,0)
        rlineEnd.x=self.x_start
        rlineEnd.dx = self.xm * 3
        rlineEnd.dy = self.ym * 2

        rline = self.get_line(doc, rlineStart, rlineEnd, colorname, width) 
        return (rlineStart, rlineEnd, rline)

    def _hline_restart_y(self, x,  hlineStart, hlineEnd):
        if (x & 1) :
            hlineStart.y = self.y_start - self.ym
            hlineEnd.y = self.y_start - self.ym
        else:
            hlineStart.y = self.y_start - 2 * self.ym
            hlineEnd.y = self.y_start - 2 * self.ym

    def _lline_restart_y (self, x, llineStart, llineEnd):
        if (x & 1) :
            llineStart.y = self.y_start - 2 * self.ym
            llineEnd.y = self.y_start - self.ym
        else:
            llineStart.y = self.y_start - self.ym
            llineEnd.y = self.y_start - 2 * self.ym

    def _rline_restart_y (self, x, rlineStart, rlineEnd):
        if (x & 1) :
            rlineStart.y = self.y_start - 3 *self.ym
            rlineEnd.y = self.y_start - 2 * self.ym
        else:
            rlineStart.y = self.y_start - 2 * self.ym
            rlineEnd.y = self.y_start - 3 * self.ym

class HexMap(Map):
    def __init__(self, galaxy, routes):
        super(HexMap, self).__init__(galaxy, routes)
        self.lineStart = PDFCursor(0,0)
        self.lineEnd   = PDFCursor(0,0)
    def document(self, sector):
        ''' Generated by the type of document'''
        path = os.path.join(self.galaxy.output_path, sector.sector_name()+" Sector.pdf")
        self.writer = PDFLite(path)
        
        title = "Sector %s" % sector
        subject = "Trade route map generated by PyRoute for Traveller"
        author = None
        keywords = None
        creator = "PyPDFLite"
        self.writer.set_information(title, subject, author, keywords, creator)
        document = self.writer.get_document()
        document.set_margins(4)
        return document

    def close(self):
        self.writer.close(
                          )
    def cursor (self, x=0, y=0):
        return PDFCursor (x,y)
    
    def sector_name(self,doc,name):
        '''Write name at the top of the document'''
        raise NotImplementedError ("Base Class")
        
    def add_line(self, pdf,start, end, colorname):
        ''' Add a line to the document, from start to end, in color'''
        color = pdf.get_color()
        color.set_color_by_name(colorname)
        pdf.add_line(cursor1=start, cursor2=end)
            
    def get_line(self, doc, start, end, colorname, width):
        ''' get a line draw method processor'''
        color = pdf.get_color()
        color.set_color_by_name(colorname)
        return PDFLine(pdf.session, pdf.page, start, end, stroke='solid', color=color, size=width)
        

class GraphicMap(Map):
    def __init__(self, galaxy, routes):
        super(GraphicMap, self).__init__(galaxy, routes)
        
    def document(self, sector):
        self.sector = sector
        self.image= Image.new("RGB", (612,792), "white")
        return ImageDraw.Draw(self.image)
    
    def close (self):
        path = os.path.join(self.galaxy.output_path, sector.sector_name()+" Sector.png")
        self.image.save(path)

    def cursor (self, x=0, y=0):
        return Cursor (x,y)

    def sector_name(self,doc,name):
        '''Write name at the top of the document'''
        raise NotImplementedError ("Base Class")
        
    def add_line(self, doc, start, end, colorname):
        color = ImageColor.getrgb(colorname)
        doc.line([(start.x, start.y), (end.x, end.y)], color)
        
    def get_line(self, doc, start, end, colorname, width):
        return GraphicLine (doc, start, end, colorname, width)
 
class GraphicLine(object):
    def __init__(self, image, lineStart, lineEnd, colorname, width):
        self.image = image
        self.lineStart = lineStart
        self.lineEnd = lineEnd
        self.color = ImageColor.getrgb(colorname)
        self.width = max(1, int(width))
        
    def _draw(self):
        self.image.line ([(self.lineStart.x, self.lineStart.y), (self.lineEnd.x, self.lineEnd.y)], self.color, self.width)
        
if __name__ == '__main__':
    sector = Sector('# Core', '# 0,0')
    galaxy = Galaxy (0,0)
    galaxy.output_path = '.'
    hexMap = HexMap(galaxy, None)
    pdf = hexMap.document(sector)
    hexMap.write_base_map (pdf, sector)
    hexMap.close()

    graphMap = GraphicMap (galaxy, None)
    img = graphMap.document (sector)
    graphMap.write_base_map(img, sector)
    graphMap.close()