"""
Created on Jan 19, 2025

@author: CyberiaResurrection
"""
import logging

from typing import Any
from typing_extensions import TypeAlias

from PyRoute.AreaItems.Galaxy import Galaxy, AreaItem
from PyRoute.Outputs.Cursor import Cursor
from PyRoute.Outputs.Colour import Colour

Scheme: TypeAlias = str


class MapOutput(object):
    def __init__(self, galaxy: Galaxy, routes: str, output_path: str, writer: str):
        self.output_path: str = output_path
        self.doc = None
        self.logger = logging.getLogger('PyRoute.Outputs.MapOutput')

        self.image_size: Cursor = Cursor(0, 0)

        self.fonts: dict[Scheme, Any] = {
            'title': None,
            'info': None,
            'sector': None,
            'system_port': None,
            'system_uwp': None,
            'system_name': None,
            'base code': None
        }
        self.colours: dict[Scheme, Colour] = {
            'background': None,
            'title': None,
            'info': None,
            'sector': None,
            'system_port': None,
            'system_uwp': None,
            'system_name': None,
            'base code': None,

            'grid': None,
            'hexes': None,
            'red zone': None,
            'amber zone': None,
            'gg refuel': None,
            'wild refuel': None,
            'comm': None,
        }

    def document(self, sector: str, is_live: bool = True):
        """
        Generated by the type of document
        """
        raise NotImplementedError("Base Class")

    def close(self) -> None:
        raise NotImplementedError("Base Class")

    def add_line(self, start: Cursor, end: Cursor, colour: Colour, stroke: str = 'solid', width: float = 1) -> None:
        """
        Add a line to the document, from start to end, in colour
        """
        raise NotImplementedError("Base Class")

    def add_rectangle(self, start: Cursor, end: Cursor, border_colour: Colour, fill_colour: Colour, width: int) -> None:
        """
        Add a filled rectangle to the document, upper right -> lower left, border + fill colour.
        :param start:
        :param end:
        :param border_colour:
        :param fill_colour:
        :param width:
        :return:
        """
        raise NotImplementedError("Base Class")

    def add_text(self, text: str, start: Cursor, scheme: Scheme) -> None:
        raise NotImplementedError("Base Class")

    def add_text_centred(self, text: str, start: Cursor, scheme: Scheme, max_width: int = -1, offset: bool = False) -> None:
        raise NotImplementedError("Base Class")

    def add_text_centred_legacy(self, text: str, start: Cursor, scheme: Scheme, max_width: int = -1) -> None:
        raise NotImplementedError("Base Class")

    def add_text_rotated(self, text: str, start: Cursor, scheme: Scheme, rotation: int) -> None:
        raise NotImplementedError("Base Class")

    def add_text_right_aligned(self, text: str, start: Cursor, scheme: Scheme) -> None:
        raise NotImplementedError("Base Class")

    def add_circle(self, center: Cursor, radius: int, line_width: int, fill: bool, scheme: Scheme) -> None:
        """
        Add a circle to the document, from start to end, in colour
        """
        raise NotImplementedError("Base Class")

    def get_font(self, scheme: Scheme):
        return self.fonts[scheme]

    def get_colour(self, scheme: Scheme):
        return self._get_colour(self.colours[scheme])

    @staticmethod
    def _get_colour(colour: Colour):
        raise NotImplementedError("Base Class")

    @staticmethod
    def _get_text_size(font, string: str) -> tuple[int, int]:
        raise NotImplementedError("Base Class")


class Map(MapOutput):

    def __init__(self, galaxy: Galaxy, routes: str, output_path: str, writer: str):
        super(Map, self).__init__(galaxy, routes, output_path, writer)
        self.logger = logging.getLogger('PyRoute.Outputs.Map')
        self.galaxy: Galaxy = galaxy
        self.routes: str = routes
        self.start: Cursor = Cursor(0, 0)
        self.hex_size: Cursor = Cursor(6, 9)
        self.system_writer_type: str = writer
        self.system_writer = None

    def write_maps(self) -> None:
        raise NotImplementedError("Base Class")

    def write_base_map(self, sector: AreaItem):
        raise NotImplementedError("Base Class")

    def area_name_title(self, area_name: str) -> None:
        """
        Set the title of the area at the top of the document as a title
        :param area_name: Name to write
        :return: None
        """
        raise NotImplementedError("Base Class")

    def draw_borders(self, sector: AreaItem):
        raise NotImplementedError("Base Class")

    def coreward_name(self, name: str):
        raise NotImplementedError("Base Class")

    def rimward_name(self, name: str):
        raise NotImplementedError("Base Class")

    def spinward_name(self, name: str):
        raise NotImplementedError("Base Class")

    def trailing_name(self, name: str):
        raise NotImplementedError("Base Class")

    # An implementation of the Liangâ€“Barsky algorithm for clipping lines.
    # https://en.wikipedia.org/wiki/Liang%E2%80%93Barsky_algorithm
    # This is used by the route drawing process when trade and comm lines cross over borders.
    @staticmethod
    def clipping(minpos: Cursor, maxpos: Cursor, start: Cursor, end: Cursor):
        p1 = -(end.x - start.x)
        p2 = -p1
        p3 = -(end.y - start.y)
        p4 = -p3

        q1 = start.x - minpos.x
        q2 = maxpos.x - start.x
        q3 = start.y - minpos.y
        q4 = maxpos.y - start.y

        posarr = [1]
        negarr = [0]

        # reject as parallel to the borders of the clipping window.
        if (p1 == 0 and q1 < 0) or (p2 == 0 and q2 < 0) or (p3 == 0 and q3 < 0) or (p4 == 0 and q4 < 0):
            return start, end

        if p1 != 0:
            r1 = q1 / p1
            r2 = q2 / p2
            if p1 < 0:
                negarr.append(r1)  # for negative p1, add it to negative array
                posarr.append(r2)  # and add p2 to positive array
            else:
                negarr.append(r2)
                posarr.append(r1)
        if p3 != 0:
            r3 = q3 / p3
            r4 = q4 / p4
            if p3 < 0:
                negarr.append(r3)
                posarr.append(r4)
            else:
                negarr.append(r4)
                posarr.append(r3)
        rn1 = max(negarr)
        rn2 = min(posarr)
        if rn1 > rn2:  # Reject as outside the clipping window
            return None, None

        # Computing new points
        xn1 = start.x + p2 * rn1
        yn1 = start.y + p4 * rn1

        xn2 = start.x + p2 * rn2
        yn2 = start.y + p4 * rn2

        return Cursor(xn1, yn1), Cursor(xn2, yn2)
